<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>BGP-Sentry Simulation Monitor</title>
<script src="https://cdn.jsdelivr.net/npm/chart.js@4/dist/chart.umd.min.js"></script>
<style>
  :root {
    --bg: #0f1117;
    --card: #1a1d27;
    --border: #2a2d3a;
    --text: #e0e0e0;
    --muted: #888;
    --accent: #4fc3f7;
    --green: #66bb6a;
    --red: #ef5350;
    --orange: #ffa726;
    --yellow: #ffee58;
    --purple: #ba68c8;
    --cyan: #26c6da;
  }
  * { margin: 0; padding: 0; box-sizing: border-box; }
  html { scroll-behavior: smooth; }
  body {
    font-family: 'Segoe UI', system-ui, -apple-system, sans-serif;
    background: var(--bg);
    color: var(--text);
    padding-top: 48px;
    padding-left: 16px;
    padding-right: 16px;
    padding-bottom: 32px;
  }

  /* ── Sticky Nav ── */
  .sticky-nav {
    position: fixed;
    top: 0;
    left: 0;
    right: 0;
    z-index: 100;
    background: rgba(15,17,23,0.95);
    backdrop-filter: blur(8px);
    border-bottom: 1px solid var(--border);
    display: flex;
    align-items: center;
    gap: 4px;
    padding: 8px 16px;
    overflow-x: auto;
    font-size: 0.7rem;
  }
  .sticky-nav a {
    color: var(--muted);
    text-decoration: none;
    padding: 4px 10px;
    border-radius: 4px;
    white-space: nowrap;
    transition: all 0.2s;
  }
  .sticky-nav a:hover { color: var(--accent); background: rgba(79,195,247,0.1); }
  .sticky-nav .nav-title {
    color: var(--accent);
    font-weight: 700;
    font-size: 0.78rem;
    margin-right: 8px;
    flex-shrink: 0;
  }

  /* ── Header ── */
  .header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    background: var(--card);
    border: 1px solid var(--border);
    border-radius: 8px;
    padding: 14px 24px;
    margin-bottom: 12px;
  }
  .header h1 { font-size: 1.2rem; color: var(--accent); }
  .header-stats { display: flex; gap: 28px; }
  .stat-box { text-align: center; }
  .stat-box .value { font-size: 1.3rem; font-weight: 700; color: var(--accent); }
  .stat-box .label { font-size: 0.68rem; color: var(--muted); text-transform: uppercase; letter-spacing: 0.5px; }

  /* ── Section ── */
  .section {
    margin-bottom: 16px;
    scroll-margin-top: 56px;
  }
  .section-title {
    font-size: 0.9rem;
    font-weight: 700;
    color: var(--accent);
    text-transform: uppercase;
    letter-spacing: 0.5px;
    margin-bottom: 10px;
    padding-bottom: 4px;
    border-bottom: 1px solid var(--border);
  }

  /* ── Timer ── */
  .timer-strip {
    display: flex;
    align-items: center;
    gap: 16px;
    background: var(--card);
    border: 1px solid var(--border);
    border-radius: 8px;
    padding: 10px 24px;
    margin-bottom: 12px;
  }
  .timer-clock {
    font-family: 'Courier New', monospace;
    font-size: 2.2rem;
    font-weight: 700;
    color: var(--accent);
    letter-spacing: 2px;
    min-width: 160px;
  }
  .timer-of { font-size: 1rem; color: var(--muted); }
  .timer-total { font-family: 'Courier New', monospace; font-size: 1.6rem; font-weight: 600; color: var(--muted); }
  .timer-remaining { margin-left: auto; text-align: right; }
  .timer-remaining .value { font-family: 'Courier New', monospace; font-size: 1.4rem; font-weight: 700; }
  .timer-remaining .label { font-size: 0.68rem; color: var(--muted); text-transform: uppercase; }
  .timer-progress { flex: 1; height: 8px; background: #12141c; border: 1px solid var(--border); border-radius: 4px; overflow: hidden; min-width: 100px; }
  .timer-progress-fill { height: 100%; background: linear-gradient(90deg, #1565c0, #4fc3f7); border-radius: 4px; transition: width 1s linear; }

  /* ── Timestamp Bars ── */
  .ts-bars {
    background: var(--card);
    border: 1px solid var(--border);
    border-radius: 8px;
    padding: 14px 24px 12px;
    margin-bottom: 12px;
  }
  .ts-bars-title { font-size: 0.75rem; color: var(--muted); text-transform: uppercase; letter-spacing: 0.5px; margin-bottom: 10px; }
  .ts-range-labels { display: flex; justify-content: space-between; font-size: 0.68rem; color: var(--muted); margin-bottom: 2px; }
  .bar-row { display: flex; align-items: center; gap: 10px; margin-bottom: 6px; }
  .bar-row:last-child { margin-bottom: 0; }
  .bar-row-label { width: 110px; flex-shrink: 0; font-size: 0.72rem; font-weight: 600; display: flex; align-items: center; gap: 6px; }
  .bar-row-track { flex: 1; height: 14px; background: #12141c; border: 1px solid var(--border); border-radius: 3px; position: relative; overflow: hidden; }
  .bar-row-fill { height: 100%; border-radius: 3px; transition: width 0.8s ease; min-width: 1px; }
  .bar-fill-clock { background: linear-gradient(90deg, #1565c0, #4fc3f7); }
  .bar-fill-avg   { background: linear-gradient(90deg, #e65100, #ffa726); }
  .bar-fill-slow  { background: linear-gradient(90deg, #b71c1c, #ef5350); }
  .bar-row-info { width: 200px; flex-shrink: 0; font-size: 0.72rem; text-align: right; font-variant-numeric: tabular-nums; }
  .bar-row-pct { width: 52px; flex-shrink: 0; font-size: 0.72rem; font-weight: 700; text-align: right; font-variant-numeric: tabular-nums; }
  .color-dot { display: inline-block; width: 8px; height: 8px; border-radius: 2px; }
  .dot-clock { background: #4fc3f7; }
  .dot-avg   { background: #ffa726; }
  .dot-slow  { background: #ef5350; }

  .lag-banner { display: flex; align-items: center; gap: 8px; margin-top: 8px; padding: 6px 12px; border-radius: 4px; font-size: 0.75rem; font-weight: 600; }
  .lag-ok   { background: rgba(102,187,106,0.12); color: var(--green); }
  .lag-warn { background: rgba(255,167,38,0.12); color: var(--orange); }
  .lag-bad  { background: rgba(239,83,80,0.15); color: var(--red); }

  /* ── RPKI Health Vertical Bars ── */
  .rpki-health {
    background: var(--card);
    border: 1px solid var(--border);
    border-radius: 8px;
    padding: 16px;
    margin-bottom: 12px;
  }
  .rpki-health h2 { font-size: 0.85rem; color: var(--muted); text-transform: uppercase; letter-spacing: 0.5px; margin-bottom: 4px; }
  .rpki-health-sub { font-size: 0.7rem; color: var(--muted); margin-bottom: 12px; }
  .vbar-container { display: flex; gap: 2px; align-items: flex-end; height: 180px; overflow-x: auto; padding-bottom: 32px; width: 100%; }
  .vbar-col { display: flex; flex-direction: column; align-items: center; flex: 1 1 0%; min-width: 0; height: 100%; position: relative; }
  .vbar-value { font-size: 0.55rem; color: var(--muted); margin-bottom: 1px; white-space: nowrap; font-variant-numeric: tabular-nums; overflow: hidden; }
  .vbar-track { width: 100%; flex: 1; background: #12141c; border: 1px solid var(--border); border-radius: 2px; position: relative; overflow: hidden; display: flex; flex-direction: column; justify-content: flex-end; }
  .vbar-fill { width: 100%; border-radius: 0 0 2px 2px; transition: height 0.6s ease; }
  .vbar-fill-ok   { background: linear-gradient(0deg, #1b5e20, #66bb6a); }
  .vbar-fill-warn { background: linear-gradient(0deg, #e65100, #ffa726); }
  .vbar-fill-bad  { background: linear-gradient(0deg, #b71c1c, #ef5350); }
  .vbar-label { font-size: 0.55rem; color: var(--muted); margin-top: 2px; position: absolute; bottom: -28px; left: 50%; transform: translateX(-50%) rotate(-90deg); transform-origin: center center; white-space: nowrap; }
  /* Scrollable mode for large node counts (>100 nodes) */
  .vbar-container.scrollable { overflow-x: scroll; }
  .vbar-container.scrollable .vbar-col { flex: 0 0 10px; }
  .vbar-container.scrollable .vbar-label { font-size: 0.4rem; }
  .vbar-container.scrollable .vbar-value { font-size: 0.4rem; }

  /* ── Grid layout ── */
  .grid { display: grid; grid-template-columns: 1fr 1fr; gap: 12px; margin-bottom: 12px; }
  .grid-3 { display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 12px; margin-bottom: 12px; }
  .grid-full { grid-column: 1 / -1; }

  .card {
    background: var(--card);
    border: 1px solid var(--border);
    border-radius: 8px;
    padding: 16px;
  }
  .card h2 { font-size: 0.85rem; color: var(--muted); text-transform: uppercase; letter-spacing: 0.5px; margin-bottom: 12px; }

  /* ── Summary card ── */
  .summary-card {
    background: rgba(79,195,247,0.08);
    border: 1px solid rgba(79,195,247,0.2);
    border-radius: 6px;
    padding: 12px 16px;
    font-size: 0.82rem;
    margin-top: 10px;
  }
  .summary-card strong { color: var(--accent); }

  /* Table */
  table { width: 100%; border-collapse: collapse; font-size: 0.82rem; }
  th { text-align: left; color: var(--muted); font-weight: 600; padding: 6px 8px; border-bottom: 1px solid var(--border); font-size: 0.72rem; text-transform: uppercase; }
  td { padding: 6px 8px; border-bottom: 1px solid var(--border); }
  tr:last-child td { border-bottom: none; }

  .progress-bar { width: 100%; height: 6px; background: var(--border); border-radius: 3px; overflow: hidden; }
  .progress-bar .fill { height: 100%; background: var(--accent); border-radius: 3px; transition: width 0.5s ease; }

  .badge { display: inline-block; padding: 2px 8px; border-radius: 4px; font-size: 0.7rem; font-weight: 600; }
  .badge-rpki { background: rgba(79,195,247,0.2); color: var(--accent); }
  .badge-done { background: rgba(102,187,106,0.2); color: var(--green); }
  .badge-running { background: rgba(79,195,247,0.15); color: var(--accent); }

  .chart-container { position: relative; height: 240px; }
  .chart-container-sm { position: relative; height: 200px; }

  .dot { display: inline-block; width: 8px; height: 8px; border-radius: 50%; margin-right: 4px; }
  .dot-green { background: var(--green); }
  .dot-red { background: var(--red); }

  /* ── Manuscript table styling ── */
  .ms-table { font-size: 0.8rem; }
  .ms-table th { background: rgba(79,195,247,0.08); }
  .ms-table td.num { text-align: right; font-variant-numeric: tabular-nums; }
  .ms-table .highlight { color: var(--accent); font-weight: 700; }

  /* ── Discussion box ── */
  .discussion {
    background: rgba(255,255,255,0.03);
    border-left: 3px solid var(--accent);
    border-radius: 0 6px 6px 0;
    padding: 10px 14px;
    margin-top: 10px;
    font-size: 0.78rem;
    line-height: 1.5;
    color: #bbb;
  }
  .discussion strong { color: var(--accent); }
  .discussion .warn { color: var(--orange); font-weight: 600; }
  .discussion .good { color: var(--green); font-weight: 600; }
  .discussion .bad { color: var(--red); font-weight: 600; }

  /* ── Activity feed ── */
  .activity-row {
    display: flex; align-items: center; gap: 8px;
    padding: 4px 8px; border-bottom: 1px solid rgba(42,45,58,0.5);
  }
  .activity-row:hover { background: rgba(79,195,247,0.05); }
  .activity-icon { width: 8px; height: 8px; border-radius: 50%; flex-shrink: 0; }
  .activity-icon-attack { background: var(--red); }
  .activity-icon-detect { background: var(--orange); }
  .activity-icon-ok { background: var(--green); }
  .activity-icon-skip { background: #555; }
  .activity-icon-tx { background: var(--accent); }
  .activity-action { color: var(--muted); font-size: 0.68rem; width: 140px; flex-shrink: 0; }
  .activity-prefix { color: var(--text); flex: 1; }
  .activity-label { font-size: 0.68rem; padding: 1px 6px; border-radius: 3px; }

  /* ── Stacked vertical bar for buffer ── */
  .vbar-stacked { display: flex; flex-direction: column; justify-content: flex-end; width: 100%; height: 100%; }
  .vbar-seg { width: 100%; transition: height 0.6s ease; }

  @media (max-width: 900px) {
    .grid, .grid-3 { grid-template-columns: 1fr; }
    .header { flex-direction: column; gap: 10px; }
    .header-stats { flex-wrap: wrap; justify-content: center; }
    .timer-strip { flex-wrap: wrap; }
    .sticky-nav { font-size: 0.62rem; }
  }
</style>
</head>
<body>

<!-- ═══ STICKY NAV ═══ -->
<nav class="sticky-nav">
  <span class="nav-title">BGP-Sentry</span>
  <a href="#header">Overview</a>
  <a href="#timer">Timer</a>
  <a href="#rpki-health">RPKI Health</a>
  <a href="#buffer-bars">Buffers</a>
  <a href="#blockchain-txns">Blockchain</a>
  <a href="#node-activity">Activity</a>
  <a href="#manuscript-figures">Figures</a>
  <a href="#manuscript-tables">Tables</a>
  <a href="#step-latency">Latency</a>
  <a href="#buffer-section">Buffers</a>
  <a href="#economy">Economy</a>
  <a href="#attacks">Attacks</a>
  <a href="#charts">Charts</a>
  <a href="#node-table">Nodes</a>
  <a href="/compare" style="color:var(--orange)">Cross-Dataset</a>
</nav>

<!-- ═══ HEADER ═══ -->
<div class="header section" id="header">
  <h1>BGP-Sentry Simulation Monitor</h1>
  <div class="header-stats">
    <div class="stat-box">
      <div class="value" id="h-nodes-done">--</div>
      <div class="label">Nodes Done</div>
    </div>
    <div class="stat-box">
      <div class="value" id="h-processed">--</div>
      <div class="label">Processed</div>
    </div>
    <div class="stat-box">
      <div class="value" id="h-attacks">--</div>
      <div class="label">Attacks</div>
    </div>
    <div class="stat-box">
      <div class="value" id="h-wall-time">--</div>
      <div class="label">Wall Time</div>
    </div>
    <div class="stat-box">
      <div class="value" id="h-tps" style="color:var(--green)">--</div>
      <div class="label">Avg TPS</div>
    </div>
    <div class="stat-box">
      <div class="value" id="h-speed">--</div>
      <div class="label">Speed</div>
    </div>
  </div>
</div>

<!-- System Info -->
<div style="display:flex;gap:16px;font-size:0.7rem;color:var(--muted);padding:0 4px;margin-bottom:8px;" id="sysinfo-bar"></div>

<!-- ═══ COUNTDOWN TIMER ═══ -->
<div class="section" id="timer">
<div class="timer-strip">
  <div>
    <div style="font-size:0.65rem;color:var(--muted);text-transform:uppercase;letter-spacing:0.5px;">Elapsed</div>
    <div class="timer-clock" id="timer-elapsed">00:00</div>
  </div>
  <div class="timer-of">/</div>
  <div>
    <div style="font-size:0.65rem;color:var(--muted);text-transform:uppercase;letter-spacing:0.5px;">Total Dataset Span</div>
    <div class="timer-total" id="timer-total">--:--</div>
  </div>
  <div class="timer-progress">
    <div class="timer-progress-fill" id="timer-fill" style="width:0%"></div>
  </div>
  <div class="timer-remaining">
    <div class="value" id="timer-remaining" style="color:var(--green)">--:--</div>
    <div class="label">Remaining</div>
  </div>
</div>

<!-- Timestamp Progress Bars -->
<div class="ts-bars">
  <div class="ts-bars-title">Timestamp Progress -- Real-Time Clock vs BGP Processing</div>
  <div class="ts-range-labels">
    <span id="ts-start">--</span>
    <span id="ts-end">--</span>
  </div>
  <div class="bar-row">
    <div class="bar-row-label"><span class="color-dot dot-clock"></span> Sim Clock</div>
    <div class="bar-row-track"><div class="bar-row-fill bar-fill-clock" id="bar-clock" style="width:0%"></div></div>
    <div class="bar-row-pct" id="bar-clock-pct">0%</div>
    <div class="bar-row-info" id="bar-clock-ts" style="color:var(--accent)">--</div>
  </div>
  <div class="bar-row">
    <div class="bar-row-label"><span class="color-dot dot-avg"></span> Avg Node</div>
    <div class="bar-row-track"><div class="bar-row-fill bar-fill-avg" id="bar-avg" style="width:0%"></div></div>
    <div class="bar-row-pct" id="bar-avg-pct">0%</div>
    <div class="bar-row-info" id="bar-avg-ts" style="color:var(--orange)">--</div>
  </div>
  <div class="bar-row">
    <div class="bar-row-label"><span class="color-dot dot-slow"></span> Slowest</div>
    <div class="bar-row-track"><div class="bar-row-fill bar-fill-slow" id="bar-slow" style="width:0%"></div></div>
    <div class="bar-row-pct" id="bar-slow-pct">0%</div>
    <div class="bar-row-info" id="bar-slow-ts" style="color:var(--red)">--</div>
  </div>
  <div class="lag-banner lag-ok" id="lag-banner">
    <span id="lag-text">No lag detected</span>
  </div>
</div>
</div>

<!-- ═══ RPKI NODE HEALTH ═══ -->
<div class="rpki-health section" id="rpki-health">
  <h2>RPKI Node Health -- Lag from Real-Time Clock</h2>
  <div class="rpki-health-sub">Each bar = one RPKI node. Height = lag (seconds behind clock).</div>
  <div class="vbar-container" id="lag-bars"></div>
</div>

<!-- ═══ BUFFER MEMORY VERTICAL BARS ═══ -->
<div class="rpki-health section" id="buffer-bars">
  <h2>Buffer & Transaction Memory per RPKI Node</h2>
  <div class="rpki-health-sub">Each column = one RPKI node. Shows ingestion buffer (blue), pending consensus votes (orange), committed transactions (green). Tall bars = memory pressure.</div>

  <div style="display:flex;gap:16px;margin-bottom:8px;font-size:0.65rem;">
    <span><span class="color-dot" style="background:#4fc3f7"></span> Ingestion Buffer</span>
    <span><span class="color-dot" style="background:#ffa726"></span> Pending Votes</span>
    <span><span class="color-dot" style="background:#66bb6a"></span> Committed TXs</span>
    <span><span class="color-dot" style="background:#ba68c8"></span> Knowledge Base</span>
    <span><span class="color-dot" style="background:#ffee58"></span> Dedup State</span>
  </div>

  <div class="vbar-container" id="buffer-vbars" style="height:160px;"></div>
  <div class="discussion" id="disc-buffer-vbars">
    <strong>Observation:</strong> Transactions are held in the <strong>pending_votes</strong> buffer while waiting for consensus signatures.
    Once enough signers approve (PoP threshold), they move to <strong>committed_txs</strong>.
    Growing pending = consensus bottleneck. Growing ingestion = node can't process fast enough.
    <span id="disc-buffer-vbars-detail"></span>
  </div>
</div>

<!-- ═══ NODE ACTIVITY LOG ═══ -->
<div class="section" id="node-activity">
  <div class="section-title">Node Activity Log</div>
  <div class="card">
    <div style="display:flex;align-items:center;gap:12px;margin-bottom:12px;">
      <h2 style="margin-bottom:0;">Live Activity Feed</h2>
      <select id="activity-node-select" style="background:var(--bg);color:var(--text);border:1px solid var(--border);border-radius:4px;padding:4px 10px;font-size:0.8rem;">
        <option value="0">Select node...</option>
      </select>
      <span id="activity-node-info" style="font-size:0.72rem;color:var(--muted);"></span>
    </div>
    <div id="activity-stats" style="display:flex;gap:20px;margin-bottom:10px;font-size:0.75rem;flex-wrap:wrap;"></div>
    <div id="activity-feed" style="max-height:350px;overflow-y:auto;font-size:0.75rem;font-family:'Courier New',monospace;">
      <div style="color:var(--muted);padding:12px;">Select a node from the dropdown to see its activity...</div>
    </div>
  </div>
</div>

<!-- ═══ BLOCKCHAIN TRANSACTIONS ═══ -->
<div class="section" id="blockchain-txns">
  <div class="section-title">Blockchain Transactions & Consensus Votes</div>
  <div class="grid">
    <div class="card">
      <h2>Transaction Summary</h2>
      <table class="ms-table">
        <thead><tr><th>Metric</th><th>Value</th></tr></thead>
        <tbody id="tbl-blockchain-summary"></tbody>
      </table>
      <div class="discussion" id="disc-blockchain">
        <strong>Analysis:</strong> Transactions are created when a node observes a BGP announcement,
        then broadcast for consensus. Signers vote approve/reject/no_knowledge. Once the PoP threshold
        is reached, the transaction is committed to the blockchain as a new block.
        <span id="disc-blockchain-detail"></span>
      </div>
    </div>
    <div class="card">
      <h2>Vote Distribution (votes per pending tx)</h2>
      <div class="chart-container-sm"><canvas id="voteDistChart"></canvas></div>
    </div>
  </div>
  <div class="card" style="margin-bottom:12px;">
    <h2>Recent Transactions (sample from pending pool)</h2>
    <div style="max-height:250px;overflow-y:auto;">
      <table class="ms-table">
        <thead><tr><th>TX ID</th><th>Observer</th><th>Prefix</th><th>Attack?</th><th>Approve</th><th>Reject</th><th>No Knowledge</th><th>Needed</th><th>Status</th></tr></thead>
        <tbody id="tbl-recent-txns"></tbody>
      </table>
    </div>
  </div>
</div>

<!-- ═══ MANUSCRIPT FIGURES ═══ -->
<div class="section" id="manuscript-figures">
  <div class="section-title">Manuscript Figures</div>
  <div class="grid">
    <!-- Fig 4a: Trust Coverage -->
    <div class="card">
      <h2>Fig 4a: Trust Coverage Convergence</h2>
      <div class="chart-container"><canvas id="trustCovChart"></canvas></div>
      <div class="discussion" id="disc-trust-cov">
        <strong>Observation:</strong> Shows the percentage of non-RPKI ASes that have received at least one trust rating.
        Coverage should converge toward 100% as the simulation progresses through the dataset.
        <span id="disc-trust-cov-detail"></span>
      </div>
    </div>
    <!-- Fig 4b: Consensus Breakdown -->
    <div class="card">
      <h2>Fig 4b: Consensus Status Breakdown</h2>
      <div class="chart-container"><canvas id="consensusChart"></canvas></div>
      <div class="discussion" id="disc-consensus">
        <strong>Observation:</strong> Stacked area shows confirmed (green) vs pending (orange) vs single-witness (red) transactions.
        A healthy system shows confirmed dominating; if pending grows, consensus is bottlenecked.
        <span id="disc-consensus-detail"></span>
      </div>
    </div>
    <!-- Fig 5a: Data Flow -->
    <div class="card grid-full">
      <h2>Fig 5a: Data Flow Pipeline</h2>
      <div class="chart-container"><canvas id="dataFlowChart"></canvas></div>
      <div class="discussion" id="disc-data-flow">
        <strong>Observation:</strong> Received (blue) vs committed (green) gap shows pipeline backlog.
        Buffer depth (orange, right axis) should stay bounded. Growing gap = blockchain can't commit fast enough.
        <span id="disc-data-flow-detail"></span>
      </div>
    </div>
  </div>
</div>

<!-- ═══ MANUSCRIPT TABLES ═══ -->
<div class="section" id="manuscript-tables">
  <div class="section-title">Manuscript Tables</div>
  <div class="grid">
    <!-- Table 3: Detection Accuracy -->
    <div class="card">
      <h2>Table 3: Detection Accuracy</h2>
      <table class="ms-table">
        <thead><tr><th>Metric</th><th>Value</th></tr></thead>
        <tbody id="tbl-detection"></tbody>
      </table>
      <div class="discussion" id="disc-detection">
        <strong>Analysis:</strong> Precision = TP/(TP+FP), Recall = TP/(TP+FN).
        High precision means few false alarms; high recall means few missed attacks.
        <span id="disc-detection-detail"></span>
      </div>
    </div>
    <!-- Table 4: Throughput & Latency -->
    <div class="card">
      <h2>Table 4: Throughput & Latency</h2>
      <table class="ms-table">
        <thead><tr><th>Metric</th><th>Value</th></tr></thead>
        <tbody id="tbl-throughput"></tbody>
      </table>
      <div class="discussion" id="disc-throughput">
        <strong>Analysis:</strong> TPS measures how many BGP observations nodes process per second.
        On a single machine, thread contention limits TPS. In production (one node per machine), TPS scales linearly.
        <span id="disc-throughput-detail"></span>
      </div>
    </div>
    <!-- Table 9: Verification -->
    <div class="card">
      <h2>Table 9: Verification & Integrity</h2>
      <table class="ms-table">
        <thead><tr><th>Check</th><th>Result</th></tr></thead>
        <tbody id="tbl-verification"></tbody>
      </table>
      <div class="discussion" id="disc-verification">
        <strong>Analysis:</strong> Blockchain integrity verification confirms hash chain consistency,
        Ed25519 signature validity, and Merkle proof correctness across all node replicas.
        <span id="disc-verification-detail"></span>
      </div>
    </div>
    <!-- Table 5: Forensic Audit -->
    <div class="card">
      <h2>Table 5: Forensic Audit</h2>
      <div style="max-height:300px;overflow-y:auto;">
        <table class="ms-table">
          <thead><tr><th>ASN</th><th>Attacks</th><th>Types</th><th>Prefixes</th><th>Trust</th></tr></thead>
          <tbody id="tbl-forensic"></tbody>
        </table>
      </div>
      <div class="discussion" id="disc-forensic">
        <strong>Analysis:</strong> Lists attacker ASes ranked by attack count with their trust scores.
        Trust scores below 30 = malicious; below 50 = suspicious. Multiple attack types indicate sophisticated adversaries.
        <span id="disc-forensic-detail"></span>
      </div>
    </div>
  </div>
</div>

<!-- ═══ PER-STEP LATENCY BREAKDOWN ═══ -->
<div class="section" id="step-latency">
  <div class="section-title">Per-Step Latency Breakdown (Key for Distributed Claim)</div>
  <div class="card">
    <h2>Pipeline Step Latency per RPKI Node</h2>
    <div class="chart-container" style="height:300px;"><canvas id="stepLatencyChart"></canvas></div>
    <div class="summary-card" id="latency-summary">
      Waiting for timing data...
    </div>
    <div class="discussion" id="disc-latency">
      <strong>Key Insight for Distributed Claim:</strong> The stacked bars show each pipeline step's latency.
      In single-machine simulation, <span class="warn">consensus_wait</span> dominates because all nodes share CPU threads.
      Per-step processing (dedup, validation, detection) is fast (&lt;1ms each).
      <strong>In a distributed deployment</strong> (one node per machine), consensus_wait drops to network RTT (~1-5ms),
      making the total pipeline latency approach the sum of per-step processing only.
      <span id="disc-latency-detail"></span>
    </div>
  </div>
</div>

<!-- ═══ BUFFER MEMORY BREAKDOWN ═══ -->
<div class="section" id="buffer-section">
  <div class="section-title">Buffer Memory Breakdown</div>
  <div class="card">
    <h2>Per-Node Buffer Types (RPKI Nodes)</h2>
    <div class="chart-container" style="height:280px;"><canvas id="bufferChart"></canvas></div>
    <div class="discussion" id="disc-buffer">
      <strong>Observation:</strong> Shows memory allocation across 6 buffer types per RPKI node.
      <strong>committed_txs</strong> and <strong>knowledge_base</strong> should grow monotonically.
      <strong>ingestion_buffer</strong> should stay near zero (draining quickly); if it fills up, the node can't keep pace.
      <strong>pending_votes</strong> spikes indicate consensus bottleneck.
      <span id="disc-buffer-detail"></span>
    </div>
  </div>
</div>

<!-- ═══ BGPCOIN & TRUST ECONOMY ═══ -->
<div class="section" id="economy">
  <div class="section-title">BGPCoin & Trust Economy</div>
  <div class="grid">
    <!-- Trust Distribution -->
    <div class="card">
      <h2>Trust Score Distribution</h2>
      <div class="chart-container-sm"><canvas id="trustDistChart"></canvas></div>
      <div class="discussion" id="disc-trust-dist">
        <strong>Observation:</strong> Histogram of trust scores across all ASes (10-point buckets).
        Healthy network: most ASes in 70-100 range (trusted/highly trusted).
        Attackers cluster in 0-30 range (malicious). A bimodal distribution confirms effective detection.
        <span id="disc-trust-dist-detail"></span>
      </div>
    </div>
    <!-- BGPCoin Balances -->
    <div class="card">
      <h2>BGPCoin Balances</h2>
      <div class="chart-container-sm"><canvas id="bgpcoinChart"></canvas></div>
      <div id="economy-summary" style="font-size:0.75rem;color:var(--muted);margin-top:8px;"></div>
      <div class="discussion" id="disc-bgpcoin">
        <strong>Observation:</strong> Shows BGPCoin distribution across RPKI validator nodes.
        Balanced distribution = fair incentive mechanism. Large imbalances may indicate one node committing disproportionately.
        Treasury depletion rate indicates long-term sustainability.
        <span id="disc-bgpcoin-detail"></span>
      </div>
    </div>
  </div>
</div>

<!-- ═══ ATTACK DETECTION ═══ -->
<div class="section" id="attacks">
  <div class="section-title">Attack Detection</div>
  <div class="grid">
    <div class="card">
      <h2>Attack Timeline</h2>
      <div class="chart-container"><canvas id="attackTimelineChart"></canvas></div>
      <div class="discussion" id="disc-attack-timeline">
        <strong>Observation:</strong> Scatter plot of detected attacks over wall time (x) by attacker ASN (y), colored by attack type.
        Clusters indicate coordinated attack campaigns. Spread-out points = sporadic events.
        <span id="disc-attack-timeline-detail"></span>
      </div>
    </div>
    <div class="card">
      <h2>Attack Type Distribution</h2>
      <div class="chart-container-sm"><canvas id="attackTypeChart"></canvas></div>
      <div class="discussion" id="disc-attack-type">
        <strong>Observation:</strong> Doughnut chart of attack type proportions.
        PREFIX_HIJACK and ROUTE_LEAK are typically the most common BGP attack vectors.
        A dominance of one type suggests dataset-specific attack patterns.
        <span id="disc-attack-type-detail"></span>
      </div>
    </div>
  </div>
</div>

<!-- ═══ EXISTING CHARTS ═══ -->
<div class="section" id="charts">
  <div class="section-title">Performance Charts</div>
  <div class="grid">
    <div class="card">
      <h2>Throughput (Avg TPS over time)</h2>
      <div class="chart-container"><canvas id="tpsChart"></canvas></div>
    </div>
    <div class="card">
      <h2>Avg Node Lag over Time</h2>
      <div class="chart-container"><canvas id="lagChart"></canvas></div>
    </div>
  </div>
</div>

<!-- ═══ NODE TABLE ═══ -->
<div class="section" id="node-table">
  <div class="section-title">Per-Node Status</div>
  <div class="card">
    <h2>RPKI Blockchain Nodes <span id="node-count-label" style="color:var(--muted);font-size:0.75rem;"></span></h2>
    <div style="max-height:500px;overflow-y:auto;">
      <table>
        <thead>
          <tr>
            <th>ASN</th>
            <th>Processed / Total</th>
            <th>Progress</th>
            <th>TPS</th>
            <th>Attacks</th>
            <th>Buffer</th>
            <th>Last BGP TS</th>
            <th>Status</th>
          </tr>
        </thead>
        <tbody id="node-tbody"></tbody>
      </table>
    </div>
  </div>
</div>

<script>
// ══════════════════════════════════════════════
// Chart.js defaults
// ══════════════════════════════════════════════
Chart.defaults.color = '#888';
Chart.defaults.borderColor = '#2a2d3a';
const CHART_OPTS = {
  responsive: true, maintainAspectRatio: false,
  animation: { duration: 0 },
  plugins: { legend: { labels: { boxWidth: 10, font: { size: 11 } } } },
};

// ══════════════════════════════════════════════
// Initialize all charts
// ══════════════════════════════════════════════

// TPS chart
const tpsChart = new Chart(document.getElementById('tpsChart'), {
  type: 'line',
  data: { labels: [], datasets: [{
    label: 'Avg TPS', data: [],
    borderColor: '#4fc3f7', backgroundColor: 'rgba(79,195,247,0.1)',
    fill: true, tension: 0.3, pointRadius: 0,
  }]},
  options: { ...CHART_OPTS, plugins: { legend: { display: false } },
    scales: {
      x: { title: { display: true, text: 'Wall time (s)' }, grid: { color: '#2a2d3a' } },
      y: { title: { display: true, text: 'TPS' }, beginAtZero: true, grid: { color: '#2a2d3a' } },
    }
  }
});

// Lag chart
const lagChart = new Chart(document.getElementById('lagChart'), {
  type: 'line',
  data: { labels: [], datasets: [{
    label: 'Avg Lag (s)', data: [],
    borderColor: '#ef5350', backgroundColor: 'rgba(239,83,80,0.1)',
    fill: true, tension: 0.3, pointRadius: 0,
  }]},
  options: { ...CHART_OPTS, plugins: { legend: { display: false } },
    scales: {
      x: { title: { display: true, text: 'Wall time (s)' }, grid: { color: '#2a2d3a' } },
      y: { title: { display: true, text: 'Lag (s)' }, beginAtZero: true, grid: { color: '#2a2d3a' } },
    }
  }
});

// Fig 4a: Trust Coverage
const trustCovChart = new Chart(document.getElementById('trustCovChart'), {
  type: 'line',
  data: { labels: [], datasets: [{
    label: 'Coverage %', data: [],
    borderColor: '#66bb6a', backgroundColor: 'rgba(102,187,106,0.12)',
    fill: true, tension: 0.3, pointRadius: 0,
  }]},
  options: { ...CHART_OPTS, plugins: { legend: { display: false } },
    scales: {
      x: { title: { display: true, text: 'Wall time (s)' }, grid: { color: '#2a2d3a' } },
      y: { title: { display: true, text: 'Coverage %' }, min: 0, max: 100, grid: { color: '#2a2d3a' } },
    }
  }
});

// Fig 4b: Consensus Breakdown
const consensusChart = new Chart(document.getElementById('consensusChart'), {
  type: 'line',
  data: { labels: [], datasets: [
    { label: 'Confirmed', data: [], borderColor: '#66bb6a', backgroundColor: 'rgba(102,187,106,0.3)', fill: true, tension: 0.3, pointRadius: 0 },
    { label: 'Pending', data: [], borderColor: '#ffa726', backgroundColor: 'rgba(255,167,38,0.3)', fill: true, tension: 0.3, pointRadius: 0 },
    { label: 'Single-Witness', data: [], borderColor: '#ef5350', backgroundColor: 'rgba(239,83,80,0.3)', fill: true, tension: 0.3, pointRadius: 0 },
  ]},
  options: { ...CHART_OPTS,
    scales: {
      x: { title: { display: true, text: 'Wall time (s)' }, grid: { color: '#2a2d3a' }, stacked: true },
      y: { title: { display: true, text: 'Transactions' }, beginAtZero: true, grid: { color: '#2a2d3a' }, stacked: true },
    }
  }
});

// Fig 5a: Data Flow
const dataFlowChart = new Chart(document.getElementById('dataFlowChart'), {
  type: 'line',
  data: { labels: [], datasets: [
    { label: 'Received', data: [], borderColor: '#4fc3f7', backgroundColor: 'rgba(79,195,247,0.1)', fill: false, tension: 0.3, pointRadius: 0, yAxisID: 'y' },
    { label: 'Committed', data: [], borderColor: '#66bb6a', backgroundColor: 'rgba(102,187,106,0.1)', fill: false, tension: 0.3, pointRadius: 0, yAxisID: 'y' },
    { label: 'Buffer Depth', data: [], borderColor: '#ffa726', backgroundColor: 'rgba(255,167,38,0.1)', fill: true, tension: 0.3, pointRadius: 0, yAxisID: 'y1' },
  ]},
  options: { ...CHART_OPTS,
    scales: {
      x: { title: { display: true, text: 'Wall time (s)' }, grid: { color: '#2a2d3a' } },
      y: { type: 'linear', position: 'left', title: { display: true, text: 'Cumulative Count' }, beginAtZero: true, grid: { color: '#2a2d3a' } },
      y1: { type: 'linear', position: 'right', title: { display: true, text: 'Buffer Depth' }, beginAtZero: true, grid: { drawOnChartArea: false } },
    }
  }
});

// Step Latency (stacked bar)
const stepLatencyChart = new Chart(document.getElementById('stepLatencyChart'), {
  type: 'bar',
  data: { labels: [], datasets: [
    { label: 'Dedup Check', data: [], backgroundColor: '#78909c' },
    { label: 'Knowledge Base', data: [], backgroundColor: '#4dd0e1' },
    { label: 'RPKI Validation', data: [], backgroundColor: '#81c784' },
    { label: 'Attack Detection', data: [], backgroundColor: '#ffb74d' },
    { label: 'TX Broadcast', data: [], backgroundColor: '#ba68c8' },
    { label: 'Consensus Wait', data: [], backgroundColor: '#ef5350' },
  ]},
  options: { ...CHART_OPTS,
    scales: {
      x: { title: { display: true, text: 'RPKI Node (ASN)' }, stacked: true, grid: { color: '#2a2d3a' } },
      y: { title: { display: true, text: 'Avg Latency (ms)' }, stacked: true, beginAtZero: true, grid: { color: '#2a2d3a' } },
    }
  }
});

// Buffer Breakdown (horizontal stacked bar)
const bufferChart = new Chart(document.getElementById('bufferChart'), {
  type: 'bar',
  data: { labels: [], datasets: [
    { label: 'Ingestion Buffer', data: [], backgroundColor: '#4fc3f7' },
    { label: 'Pending Votes', data: [], backgroundColor: '#ffa726' },
    { label: 'Committed TXs', data: [], backgroundColor: '#66bb6a' },
    { label: 'Knowledge Base', data: [], backgroundColor: '#ba68c8' },
    { label: 'Last Seen Cache', data: [], backgroundColor: '#ffee58' },
    { label: 'Dedup State', data: [], backgroundColor: '#ef5350' },
  ]},
  options: { ...CHART_OPTS, indexAxis: 'y',
    scales: {
      x: { title: { display: true, text: 'Entries' }, stacked: true, beginAtZero: true, grid: { color: '#2a2d3a' } },
      y: { title: { display: true, text: 'Node' }, stacked: true, grid: { color: '#2a2d3a' } },
    }
  }
});

// Trust Distribution (histogram)
const trustDistChart = new Chart(document.getElementById('trustDistChart'), {
  type: 'bar',
  data: { labels: [], datasets: [{
    label: 'ASes', data: [],
    backgroundColor: [
      '#ef5350','#ef5350','#ff7043','#ffa726','#ffee58',
      '#ffee58','#c5e1a5','#81c784','#66bb6a','#66bb6a'
    ],
  }]},
  options: { ...CHART_OPTS, plugins: { legend: { display: false } },
    scales: {
      x: { title: { display: true, text: 'Trust Score Range' }, grid: { color: '#2a2d3a' } },
      y: { title: { display: true, text: 'AS Count' }, beginAtZero: true, grid: { color: '#2a2d3a' } },
    }
  }
});

// BGPCoin Balances
const bgpcoinChart = new Chart(document.getElementById('bgpcoinChart'), {
  type: 'bar',
  data: { labels: [], datasets: [{
    label: 'Balance', data: [],
    backgroundColor: '#ffa726',
  }]},
  options: { ...CHART_OPTS, plugins: { legend: { display: false } },
    scales: {
      x: { title: { display: true, text: 'Node' }, grid: { color: '#2a2d3a' } },
      y: { title: { display: true, text: 'BGPCoin' }, beginAtZero: true, grid: { color: '#2a2d3a' } },
    }
  }
});

// Attack Timeline (scatter)
const attackTimelineChart = new Chart(document.getElementById('attackTimelineChart'), {
  type: 'scatter',
  data: { datasets: [] },
  options: { ...CHART_OPTS,
    scales: {
      x: { title: { display: true, text: 'Wall time (s)' }, grid: { color: '#2a2d3a' } },
      y: { title: { display: true, text: 'Attacker ASN' }, grid: { color: '#2a2d3a' } },
    }
  }
});

// Attack Type Distribution (doughnut)
const attackTypeChart = new Chart(document.getElementById('attackTypeChart'), {
  type: 'doughnut',
  data: { labels: [], datasets: [{
    data: [],
    backgroundColor: ['#ef5350', '#ffa726', '#ffee58', '#66bb6a', '#4fc3f7', '#ba68c8'],
  }]},
  options: { ...CHART_OPTS, plugins: { legend: { position: 'right', labels: { font: { size: 11 } } } } }
});

// Vote Distribution chart
const voteDistChart = new Chart(document.getElementById('voteDistChart'), {
  type: 'bar',
  data: { labels: [], datasets: [{
    label: 'Transactions', data: [],
    backgroundColor: '#4fc3f7',
  }]},
  options: { ...CHART_OPTS, plugins: { legend: { display: false } },
    scales: {
      x: { title: { display: true, text: 'Vote Count' }, grid: { color: '#2a2d3a' } },
      y: { title: { display: true, text: 'Transactions' }, beginAtZero: true, grid: { color: '#2a2d3a' } },
    }
  }
});

// ══════════════════════════════════════════════
// Helpers
// ══════════════════════════════════════════════
function fmt(n) {
  if (n === null || n === undefined) return '--';
  if (typeof n === 'number') return n.toLocaleString();
  return n;
}
function fmtTime(s) {
  if (s === null || s === undefined) return '--';
  const m = Math.floor(s / 60);
  const sec = Math.floor(s % 60);
  return m > 0 ? `${m}m ${sec}s` : `${sec}s`;
}
function fmtMMSS(s) {
  if (s === null || s === undefined || s < 0) return '--:--';
  const m = Math.floor(s / 60);
  const sec = Math.floor(s % 60);
  return String(m).padStart(2, '0') + ':' + String(sec).padStart(2, '0');
}
function fmtTsShort(ts) {
  if (!ts) return '--';
  try { const d = new Date(ts * 1000); return d.toISOString().slice(5, 19).replace('T', ' '); }
  catch { return String(ts); }
}

async function fetchJSON(url) {
  const r = await fetch(url);
  return r.json();
}

// ══════════════════════════════════════════════
// Polling
// ══════════════════════════════════════════════
const POLL_MS = 2000;

async function poll() {
  try {
    // Fetch all data in parallel
    const [overview, nodes, clock, tpsHistory, rpkiHealth, lagHistory,
           trustCov, consensusBD, dataFlow, detection, throughput,
           forensic, verification, trustDist, bufferBD, bgpcoin,
           attackTL, stepLatency, bcDetail] = await Promise.all([
      fetchJSON('/api/overview'),
      fetchJSON('/api/nodes'),
      fetchJSON('/api/clock'),
      fetchJSON('/api/tps_history'),
      fetchJSON('/api/rpki_health'),
      fetchJSON('/api/lag_history'),
      fetchJSON('/api/trust_coverage'),
      fetchJSON('/api/consensus_breakdown'),
      fetchJSON('/api/data_flow'),
      fetchJSON('/api/detection_accuracy'),
      fetchJSON('/api/throughput_latency'),
      fetchJSON('/api/forensic_audit'),
      fetchJSON('/api/verification'),
      fetchJSON('/api/trust_distribution'),
      fetchJSON('/api/buffer_breakdown'),
      fetchJSON('/api/bgpcoin'),
      fetchJSON('/api/attack_timeline'),
      fetchJSON('/api/step_latency'),
      fetchJSON('/api/blockchain_detail'),
    ]);

    // ── Header stats ──
    document.getElementById('h-nodes-done').textContent = `${overview.nodes_done}/${overview.total_nodes}`;
    document.getElementById('h-processed').textContent = fmt(overview.total_processed);
    document.getElementById('h-attacks').textContent = fmt(overview.attacks_detected);
    document.getElementById('h-wall-time').textContent = fmtTime(overview.wall_time);
    document.getElementById('h-speed').textContent = `${overview.speed_multiplier}x`;
    const latestTps = tpsHistory.length > 0 ? tpsHistory[tpsHistory.length - 1].tps : 0;
    document.getElementById('h-tps').textContent = latestTps.toFixed(1);

    // ── Timer ──
    const datasetSpan = (clock.bgp_ts_max && clock.bgp_ts_min) ? clock.bgp_ts_max - clock.bgp_ts_min : 0;
    const wallElapsed = clock.wall_time || 0;
    const remaining = Math.max(0, datasetSpan - wallElapsed);
    const timerPct = datasetSpan > 0 ? Math.min(100, wallElapsed / datasetSpan * 100) : 0;
    document.getElementById('timer-elapsed').textContent = fmtMMSS(wallElapsed);
    document.getElementById('timer-total').textContent = fmtMMSS(datasetSpan);
    document.getElementById('timer-remaining').textContent = remaining <= 0 ? 'DONE' : fmtMMSS(remaining);
    document.getElementById('timer-fill').style.width = timerPct + '%';
    const remEl = document.getElementById('timer-remaining');
    remEl.style.color = remaining <= 0 ? 'var(--green)' : timerPct > 90 ? 'var(--orange)' : 'var(--green)';

    // ── Timestamp bars ──
    document.getElementById('ts-start').textContent = fmtTsShort(clock.bgp_ts_min);
    document.getElementById('ts-end').textContent = fmtTsShort(clock.bgp_ts_max);
    document.getElementById('bar-clock').style.width = (clock.clock_progress_pct||0) + '%';
    document.getElementById('bar-clock-pct').textContent = (clock.clock_progress_pct||0).toFixed(1) + '%';
    document.getElementById('bar-clock-ts').textContent = fmtTsShort(clock.current_bgp_ts);
    document.getElementById('bar-avg').style.width = (clock.avg_progress_pct||0) + '%';
    document.getElementById('bar-avg-pct').textContent = (clock.avg_progress_pct||0).toFixed(1) + '%';
    document.getElementById('bar-avg-ts').textContent = fmtTsShort(clock.avg_node_ts);
    document.getElementById('bar-slow').style.width = (clock.slowest_progress_pct||0) + '%';
    document.getElementById('bar-slow-pct').textContent = (clock.slowest_progress_pct||0).toFixed(1) + '%';
    document.getElementById('bar-slow-ts').textContent = fmtTsShort(clock.slowest_node_ts);

    // Lag banner
    const lag = clock.lag_seconds || 0;
    const lagEl = document.getElementById('lag-banner');
    const lagText = document.getElementById('lag-text');
    if (lag <= 5) { lagEl.className = 'lag-banner lag-ok'; lagText.textContent = `Lag: ${lag.toFixed(1)}s -- nodes keeping up`; }
    else if (lag <= 30) { lagEl.className = 'lag-banner lag-warn'; lagText.textContent = `Lag: ${lag.toFixed(1)}s -- slightly behind`; }
    else { lagEl.className = 'lag-banner lag-bad'; lagText.textContent = `Lag: ${lag.toFixed(1)}s -- falling behind`; }

    // ── RPKI Health Bars ──
    if (rpkiHealth && rpkiHealth.length > 0) {
      const maxLag = Math.max(10, ...rpkiHealth.map(n => n.lag_seconds));
      const lagEl_ = document.getElementById('lag-bars');
      lagEl_.innerHTML = rpkiHealth.map(n => {
        const pct = Math.min(100, (n.lag_seconds / maxLag) * 100);
        const cls = n.lag_seconds <= 5 ? 'vbar-fill-ok' : n.lag_seconds <= 30 ? 'vbar-fill-warn' : 'vbar-fill-bad';
        return `<div class="vbar-col"><div class="vbar-value">${n.lag_seconds.toFixed(0)}s</div><div class="vbar-track"><div class="vbar-fill ${cls}" style="height:${pct}%"></div></div><div class="vbar-label">${n.asn}</div></div>`;
      }).join('');
      // Switch to scrollable narrow mode only when nodes won't fit comfortably
      // Each bar needs ~12px minimum to look decent; if that exceeds container, go scrollable
      const lagContW = lagEl_.parentElement.clientWidth;
      lagEl_.classList.toggle('scrollable', rpkiHealth.length * 12 > lagContW);
    }

    // ── Buffer Memory Vertical Bars ──
    if (bufferBD.length > 0) {
      // Find max total across nodes for scaling
      const totals = bufferBD.map(n => (n.ingestion_buffer||0) + (n.pending_votes||0) + (n.committed_txs||0) + (n.knowledge_base||0) + (n.dedup_state||0));
      const maxTotal = Math.max(10, ...totals);

      const bufEl_ = document.getElementById('buffer-vbars');
      bufEl_.innerHTML = bufferBD.map((n, i) => {
        const ib = n.ingestion_buffer || 0;
        const pv = n.pending_votes || 0;
        const ct = n.committed_txs || 0;
        const kb = n.knowledge_base || 0;
        const ds = n.dedup_state || 0;
        const total = ib + pv + ct + kb + ds;
        const scale = (v) => (v / maxTotal * 100).toFixed(1);
        return `<div class="vbar-col">
          <div class="vbar-value">${total}</div>
          <div class="vbar-track">
            <div class="vbar-stacked">
              <div class="vbar-seg" style="height:${scale(ds)}%;background:#ffee58"></div>
              <div class="vbar-seg" style="height:${scale(kb)}%;background:#ba68c8"></div>
              <div class="vbar-seg" style="height:${scale(ct)}%;background:#66bb6a"></div>
              <div class="vbar-seg" style="height:${scale(pv)}%;background:#ffa726"></div>
              <div class="vbar-seg" style="height:${scale(ib)}%;background:#4fc3f7"></div>
            </div>
          </div>
          <div class="vbar-label">${n.asn}</div>
        </div>`;
      }).join('');
      // Switch to scrollable narrow mode only when nodes won't fit comfortably
      const bufContW = bufEl_.parentElement.clientWidth;
      bufEl_.classList.toggle('scrollable', bufferBD.length * 12 > bufContW);

      // Discussion update
      const maxPV = Math.max(...bufferBD.map(n => n.pending_votes || 0));
      const maxIB = Math.max(...bufferBD.map(n => n.ingestion_buffer || 0));
      const totalCommitted = bufferBD.reduce((s, n) => s + (n.committed_txs || 0), 0);
      const el = document.getElementById('disc-buffer-vbars-detail');
      let msg = '<br>Total committed across all nodes: <strong>' + totalCommitted + '</strong>. ';
      if (maxPV > 100) msg += '<span class="warn">High pending votes (max ' + maxPV + ') -- consensus queue backing up.</span> ';
      else msg += '<span class="good">Pending votes healthy (max ' + maxPV + ').</span> ';
      if (maxIB > 20) msg += '<span class="warn">Ingestion buffers filling (max ' + maxIB + ').</span>';
      else msg += '<span class="good">Ingestion buffers draining well.</span>';
      el.innerHTML = msg;
    }

    // ── Blockchain Transactions & Votes ──
    if (bcDetail) {
      const commitRate = bcDetail.total_created > 0
        ? (bcDetail.total_committed / bcDetail.total_created * 100).toFixed(1) : '0';
      document.getElementById('tbl-blockchain-summary').innerHTML = [
        ['Total Blocks', fmt(bcDetail.total_blocks)],
        ['Blockchain Transactions', fmt(bcDetail.total_blockchain_txns)],
        ['<strong>TX Created (all nodes)</strong>', `<span class="highlight">${fmt(bcDetail.total_created)}</span>`],
        ['<strong>TX Committed (consensus)</strong>', `<span class="highlight">${fmt(bcDetail.total_committed)}</span>`],
        ['TX Pending', fmt(bcDetail.total_pending)],
        ['<strong>Commit Rate</strong>', `<span class="highlight">${commitRate}%</span>`],
        ['Consensus Threshold (PoP)', `${bcDetail.consensus_threshold} signers`],
      ].map(([k,v]) => `<tr><td>${k}</td><td class="num">${v}</td></tr>`).join('');

      // Discussion
      const el = document.getElementById('disc-blockchain-detail');
      if (bcDetail.total_committed > 0) {
        let msg = '<br>Commit rate: <strong>' + commitRate + '%</strong>. ';
        if (parseFloat(commitRate) > 80) msg += '<span class="good">Healthy consensus -- most transactions reach PoP threshold.</span>';
        else if (parseFloat(commitRate) > 40) msg += '<span class="warn">Moderate commit rate. Thread contention slowing vote collection.</span>';
        else msg += '<span class="bad">Low commit rate. Consensus bottleneck -- consider increasing timeout or reducing threshold in distributed deployment.</span>';
        el.innerHTML = msg;
      }

      // Vote distribution chart
      if (bcDetail.vote_distribution) {
        const labels = Object.keys(bcDetail.vote_distribution).sort((a,b) => parseInt(a)-parseInt(b));
        voteDistChart.data.labels = labels.map(l => l + ' votes');
        voteDistChart.data.datasets[0].data = labels.map(l => bcDetail.vote_distribution[l]);
        voteDistChart.update();
      }

      // Recent transactions table
      if (bcDetail.recent_transactions && bcDetail.recent_transactions.length > 0) {
        document.getElementById('tbl-recent-txns').innerHTML = bcDetail.recent_transactions.map(tx =>
          `<tr>
            <td style="font-size:0.68rem">${tx.tx_id}</td>
            <td>AS${tx.observer_as}</td>
            <td>${tx.prefix}</td>
            <td>${tx.is_attack ? '<span style="color:var(--red)">YES</span>' : 'no'}</td>
            <td class="num" style="color:var(--green)">${tx.approve}</td>
            <td class="num" style="color:var(--red)">${tx.reject}</td>
            <td class="num" style="color:var(--muted)">${tx.no_knowledge}</td>
            <td class="num">${tx.needed}</td>
            <td>${tx.status === 'committed' ? '<span style="color:var(--green)">Committed</span>' : '<span style="color:var(--orange)">Pending</span>'}</td>
          </tr>`
        ).join('');
      } else {
        document.getElementById('tbl-recent-txns').innerHTML = '<tr><td colspan="9" style="color:var(--muted)">No transactions yet</td></tr>';
      }
    }

    // ── Populate node dropdown (once) ──
    const sel = document.getElementById('activity-node-select');
    if (sel.options.length <= 1 && nodes.length > 0) {
      const rpki = nodes.filter(n => n.is_rpki);
      rpki.forEach(n => {
        const opt = document.createElement('option');
        opt.value = n.asn;
        opt.textContent = 'AS' + n.asn + (n.running ? ' (running)' : ' (done)');
        sel.appendChild(opt);
      });
    }

    // ── Fig 4a: Trust Coverage ──
    if (trustCov.history && trustCov.history.length > 0) {
      trustCovChart.data.labels = trustCov.history.map(p => p.t);
      trustCovChart.data.datasets[0].data = trustCov.history.map(p => p.coverage);
      trustCovChart.update();
    }

    // ── Fig 4b: Consensus Breakdown ──
    if (consensusBD.history && consensusBD.history.length > 0) {
      const h = consensusBD.history;
      consensusChart.data.labels = h.map(p => p.t);
      consensusChart.data.datasets[0].data = h.map(p => p.confirmed);
      consensusChart.data.datasets[1].data = h.map(p => p.pending);
      consensusChart.data.datasets[2].data = h.map(p => p.single_witness);
      consensusChart.update();
    }

    // ── Fig 5a: Data Flow ──
    if (dataFlow.history && dataFlow.history.length > 0) {
      const h = dataFlow.history;
      dataFlowChart.data.labels = h.map(p => p.t);
      dataFlowChart.data.datasets[0].data = h.map(p => p.received);
      dataFlowChart.data.datasets[1].data = h.map(p => p.committed);
      dataFlowChart.data.datasets[2].data = h.map(p => p.buffer_depth);
      dataFlowChart.update();
    }

    // ── Table 3: Detection Accuracy ──
    document.getElementById('tbl-detection').innerHTML = [
      ['True Positives', fmt(detection.true_positives)],
      ['False Positives', fmt(detection.false_positives)],
      ['False Negatives', fmt(detection.false_negatives)],
      ['True Negatives', fmt(detection.true_negatives)],
      ['<strong>Precision</strong>', `<span class="highlight">${detection.precision}%</span>`],
      ['<strong>Recall</strong>', `<span class="highlight">${detection.recall}%</span>`],
      ['<strong>F1 Score</strong>', `<span class="highlight">${detection.f1_score}%</span>`],
      ['Blockchain Blocks', fmt(detection.blockchain_blocks)],
      ['Blockchain TXs', fmt(detection.blockchain_txns)],
      ['Consensus Committed', fmt(detection.consensus_committed)],
    ].map(([k,v]) => `<tr><td>${k}</td><td class="num">${v}</td></tr>`).join('');

    // ── Table 4: Throughput & Latency ──
    document.getElementById('tbl-throughput').innerHTML = [
      ['Wall Time', fmtTime(throughput.wall_time_s)],
      ['Total Processed', fmt(throughput.total_processed)],
      ['<strong>Avg TPS</strong>', `<span class="highlight">${throughput.avg_tps}</span>`],
      ['Clock Progress', `${throughput.clock_progress_pct}%`],
      ['Avg Lag', `${throughput.lag_seconds}s`],
      ['Speed Multiplier', `${throughput.speed_multiplier}x`],
    ].map(([k,v]) => `<tr><td>${k}</td><td class="num">${v}</td></tr>`).join('');

    // ── Table 9: Verification ──
    document.getElementById('tbl-verification').innerHTML = [
      ['Chain Valid', verification.chain_valid ? '<span style="color:var(--green)">PASS</span>' : '<span style="color:var(--red)">FAIL</span>'],
      ['Total Blocks', fmt(verification.total_blocks)],
      ['Replicas Valid', `${verification.replicas_valid}/${verification.replicas_total}`],
      ['Key Algorithm', verification.key_algorithm || 'Ed25519'],
      ['Key Pairs', fmt(verification.total_key_pairs)],
      ['Errors', verification.errors && verification.errors.length > 0 ? `<span style="color:var(--red)">${verification.errors.length}</span>` : '<span style="color:var(--green)">0</span>'],
    ].map(([k,v]) => `<tr><td>${k}</td><td class="num">${v}</td></tr>`).join('');

    // ── Table 5: Forensic Audit ──
    document.getElementById('tbl-forensic').innerHTML = forensic.map(f =>
      `<tr><td><strong>AS${f.asn}</strong></td><td class="num">${f.attack_count}</td><td>${f.attack_types.join(', ')}</td><td class="num">${f.prefixes_affected}</td><td class="num" style="color:${f.trust_score < 30 ? 'var(--red)' : f.trust_score < 50 ? 'var(--orange)' : 'var(--green)'}">${f.trust_score}</td></tr>`
    ).join('') || '<tr><td colspan="5" style="color:var(--muted)">No attackers detected yet</td></tr>';

    // ── Step Latency ──
    if (stepLatency.length > 0) {
      const steps = ['dedup_check', 'knowledge_base', 'rpki_validation', 'attack_detection', 'tx_broadcast', 'consensus_wait'];
      stepLatencyChart.data.labels = stepLatency.map(n => `AS${n.asn}`);
      steps.forEach((step, i) => {
        stepLatencyChart.data.datasets[i].data = stepLatency.map(n => n[step + '_ms'] || 0);
      });
      stepLatencyChart.update();

      // Summary
      let totalAll = 0, totalConsensus = 0;
      stepLatency.forEach(n => {
        const pipeline = n.total_pipeline_ms || 0;
        const cw = n.consensus_wait_ms || 0;
        totalAll += pipeline;
        totalConsensus += cw;
      });
      const pct = totalAll > 0 ? (totalConsensus / totalAll * 100).toFixed(1) : 0;
      const avgConsensus = stepLatency.length > 0 ? (totalConsensus / stepLatency.length).toFixed(1) : 0;
      document.getElementById('latency-summary').innerHTML =
        `<strong>consensus_wait</strong> accounts for <strong>${pct}%</strong> of total pipeline (avg ${avgConsensus}ms/obs). ` +
        `In a distributed deployment with one node per machine, this contention approaches zero, ` +
        `leaving only the fast per-step processing (~${stepLatency.length > 0 ? ((totalAll - totalConsensus) / stepLatency.length).toFixed(2) : 0}ms avg).`;
    }

    // ── Buffer Breakdown ──
    if (bufferBD.length > 0) {
      const fields = ['ingestion_buffer', 'pending_votes', 'committed_txs', 'knowledge_base', 'last_seen_cache', 'dedup_state'];
      bufferChart.data.labels = bufferBD.map(n => `AS${n.asn}`);
      fields.forEach((f, i) => {
        bufferChart.data.datasets[i].data = bufferBD.map(n => n[f] || 0);
      });
      bufferChart.update();
    }

    // ── Trust Distribution ──
    if (trustDist.labels) {
      trustDistChart.data.labels = trustDist.labels;
      trustDistChart.data.datasets[0].data = trustDist.counts;
      trustDistChart.update();
    }

    // ── BGPCoin ──
    if (bgpcoin.balances && bgpcoin.balances.length > 0) {
      bgpcoinChart.data.labels = bgpcoin.balances.map(b => `AS${b.asn}`);
      bgpcoinChart.data.datasets[0].data = bgpcoin.balances.map(b => b.balance);
      bgpcoinChart.update();
      if (bgpcoin.summary) {
        const s = bgpcoin.summary;
        document.getElementById('economy-summary').innerHTML =
          `Supply: ${fmt(s.total_supply)} | Treasury: ${fmt(s.treasury_balance)} | ` +
          `Distributed: ${fmt(s.total_distributed)} | Burned: ${fmt(s.total_burned)}`;
      }
    }

    // ── Attack Timeline ──
    if (attackTL.length > 0) {
      const typeColors = {
        'PREFIX_HIJACK': '#ef5350', 'SUBPREFIX_HIJACK': '#ff7043',
        'ROUTE_LEAK': '#ffa726', 'ROUTE_FLAPPING': '#ffee58',
        'BOGON_INJECTION': '#ba68c8',
      };
      const byType = {};
      attackTL.forEach(a => {
        const t = a.type || 'UNKNOWN';
        if (!byType[t]) byType[t] = [];
        byType[t].push({ x: a.t, y: a.asn });
      });
      attackTimelineChart.data.datasets = Object.entries(byType).map(([type, pts]) => ({
        label: type,
        data: pts,
        backgroundColor: typeColors[type] || '#4fc3f7',
        pointRadius: 4,
      }));
      attackTimelineChart.update();

      // Attack type doughnut
      const typeCounts = {};
      attackTL.forEach(a => { const t = a.type || 'UNKNOWN'; typeCounts[t] = (typeCounts[t]||0)+1; });
      attackTypeChart.data.labels = Object.keys(typeCounts);
      attackTypeChart.data.datasets[0].data = Object.values(typeCounts);
      attackTypeChart.update();
    }

    // ══ Dynamic Discussion Updates ══

    // Trust coverage discussion
    if (trustCov.coverage_pct !== undefined) {
      const el = document.getElementById('disc-trust-cov-detail');
      if (trustCov.coverage_pct >= 90) el.innerHTML = '<br><span class="good">Coverage is excellent (' + trustCov.coverage_pct + '%). Nearly all non-RPKI ASes have been rated.</span>';
      else if (trustCov.coverage_pct >= 50) el.innerHTML = '<br><span class="warn">Coverage at ' + trustCov.coverage_pct + '%. Still converging -- more observations needed for full coverage.</span>';
      else el.innerHTML = '<br><span class="bad">Coverage low (' + trustCov.coverage_pct + '%). Simulation still early or dataset has limited non-RPKI observations.</span>';
    }

    // Consensus discussion
    if (consensusBD.total_created > 0) {
      const commitRate = (consensusBD.confirmed / consensusBD.total_created * 100).toFixed(1);
      const el = document.getElementById('disc-consensus-detail');
      if (commitRate > 80) el.innerHTML = '<br><span class="good">Commit rate: ' + commitRate + '%. Consensus is healthy -- most transactions achieve PoP threshold.</span>';
      else if (commitRate > 50) el.innerHTML = '<br><span class="warn">Commit rate: ' + commitRate + '%. Some transactions not reaching consensus. Possible optimization: increase signer pool or reduce PoP threshold.</span>';
      else el.innerHTML = '<br><span class="bad">Commit rate: ' + commitRate + '%. Consensus bottleneck detected. Many transactions stuck as single-witness. Thread contention on single machine is likely cause.</span>';
    }

    // Data flow discussion
    if (dataFlow.received > 0) {
      const commitRatio = dataFlow.committed / dataFlow.received;
      const el = document.getElementById('disc-data-flow-detail');
      if (commitRatio > 0.8) el.innerHTML = '<br><span class="good">Pipeline healthy: ' + (commitRatio*100).toFixed(0) + '% of received observations committed to blockchain.</span>';
      else if (commitRatio > 0.3) el.innerHTML = '<br><span class="warn">Pipeline backlog: only ' + (commitRatio*100).toFixed(0) + '% committed. Buffer depth: ' + dataFlow.buffer_depth + '. Blockchain write throughput is a bottleneck.</span>';
      else el.innerHTML = '<br><span class="bad">Severe pipeline congestion: ' + (commitRatio*100).toFixed(0) + '% commit rate. Blockchain cannot keep up. Optimization: batch transactions, increase block size, or parallelize consensus.</span>';
    }

    // Detection accuracy discussion
    if (detection.precision !== undefined) {
      const el = document.getElementById('disc-detection-detail');
      let msg = '<br>';
      if (detection.precision >= 95 && detection.recall >= 95) msg += '<span class="good">Excellent: both precision (' + detection.precision + '%) and recall (' + detection.recall + '%) are high. The detection system reliably identifies attacks with minimal false positives.</span>';
      else if (detection.precision >= 80) msg += '<span class="warn">Good precision (' + detection.precision + '%) but recall (' + detection.recall + '%) could improve. Some attacks go undetected -- consider tuning detection thresholds or adding more validators.</span>';
      else if (detection.false_positives > detection.true_positives) msg += '<span class="bad">High false positive rate (FP=' + detection.false_positives + ' > TP=' + detection.true_positives + '). Detection thresholds too aggressive -- legitimate traffic flagged as attacks.</span>';
      else msg += 'Precision: ' + detection.precision + '%, Recall: ' + detection.recall + '%. F1: ' + detection.f1_score + '%.';
      el.innerHTML = msg;
    }

    // Throughput discussion
    if (throughput.avg_tps !== undefined) {
      const el = document.getElementById('disc-throughput-detail');
      let msg = '<br>Current avg TPS: <strong>' + throughput.avg_tps + '</strong>. ';
      if (throughput.lag_seconds > 30) msg += '<span class="bad">High lag (' + throughput.lag_seconds + 's) -- nodes falling behind clock. CPU thread contention on single-machine deployment. In production (one node/machine), lag would be near zero.</span>';
      else if (throughput.lag_seconds > 5) msg += '<span class="warn">Moderate lag (' + throughput.lag_seconds + 's). Nodes slightly behind. Acceptable for simulation but indicates room for optimization.</span>';
      else msg += '<span class="good">Low lag (' + throughput.lag_seconds + 's). Nodes keeping pace with clock.</span>';
      el.innerHTML = msg;
    }

    // Verification discussion
    if (verification.chain_valid !== undefined) {
      const el = document.getElementById('disc-verification-detail');
      if (verification.chain_valid && verification.replicas_valid === verification.replicas_total)
        el.innerHTML = '<br><span class="good">All integrity checks pass. Chain hash valid, all ' + verification.replicas_total + ' replicas consistent. Ed25519 signatures verified.</span>';
      else if (verification.chain_valid)
        el.innerHTML = '<br><span class="warn">Primary chain valid but ' + (verification.replicas_total - verification.replicas_valid) + '/' + verification.replicas_total + ' replicas have issues. May indicate replication lag.</span>';
      else
        el.innerHTML = '<br><span class="bad">Chain integrity FAILED. ' + (verification.errors||[]).length + ' errors detected. Possible data corruption or consensus fork.</span>';
    }

    // Forensic discussion
    if (forensic.length > 0) {
      const el = document.getElementById('disc-forensic-detail');
      const worstASN = forensic[0];
      const multiType = forensic.filter(f => f.attack_types.length > 1);
      el.innerHTML = '<br>Top attacker: <strong>AS' + worstASN.asn + '</strong> with ' + worstASN.attack_count + ' attacks (trust: ' + worstASN.trust_score + '). ' +
        (multiType.length > 0 ? '<span class="warn">' + multiType.length + ' ASes show multiple attack types -- sophisticated adversaries.</span>' : 'All attackers show single attack type.');
    }

    // Buffer discussion
    if (bufferBD.length > 0) {
      const el = document.getElementById('disc-buffer-detail');
      const maxPending = Math.max(...bufferBD.map(n => n.pending_votes));
      const maxIngestion = Math.max(...bufferBD.map(n => n.ingestion_buffer));
      let msg = '<br>';
      if (maxPending > 100) msg += '<span class="warn">High pending_votes (max ' + maxPending + ') -- consensus decisions queuing up.</span> ';
      if (maxIngestion > 50) msg += '<span class="warn">Ingestion buffer not draining fast enough (max ' + maxIngestion + ').</span> ';
      if (maxPending <= 100 && maxIngestion <= 50) msg += '<span class="good">All buffers within normal bounds. Memory usage is healthy.</span>';
      el.innerHTML = msg;
    }

    // Trust distribution discussion
    if (trustDist.counts) {
      const el = document.getElementById('disc-trust-dist-detail');
      const lowTrust = (trustDist.counts[0]||0) + (trustDist.counts[1]||0) + (trustDist.counts[2]||0);
      const highTrust = (trustDist.counts[7]||0) + (trustDist.counts[8]||0) + (trustDist.counts[9]||0);
      const total = trustDist.counts.reduce((a,b)=>a+b,0);
      if (total > 0) {
        el.innerHTML = '<br>High trust (70-100): <span class="good">' + highTrust + '</span> ASes. Low trust (0-30): <span class="bad">' + lowTrust + '</span> ASes. ' +
          (lowTrust > 0 && highTrust > lowTrust ? 'Bimodal distribution confirms effective attack detection.' : '');
      }
    }

    // Attack timeline discussion
    if (attackTL.length > 0) {
      const el = document.getElementById('disc-attack-timeline-detail');
      const types = {};
      attackTL.forEach(a => { types[a.type] = (types[a.type]||0)+1; });
      const dominant = Object.entries(types).sort((a,b)=>b[1]-a[1])[0];
      el.innerHTML = '<br>' + attackTL.length + ' total attack events detected. Dominant type: <strong>' + dominant[0] + '</strong> (' + dominant[1] + ' events, ' + (dominant[1]/attackTL.length*100).toFixed(0) + '%).';
    }

    // ── TPS chart ──
    tpsChart.data.labels = tpsHistory.map(p => p.t);
    tpsChart.data.datasets[0].data = tpsHistory.map(p => p.tps);
    tpsChart.update();

    // ── Lag chart ──
    lagChart.data.labels = lagHistory.map(p => p.t);
    lagChart.data.datasets[0].data = lagHistory.map(p => p.lag);
    lagChart.update();

    // ── Node table ──
    const rpkiNodes = nodes.filter(n => n.is_rpki);
    document.getElementById('node-count-label').textContent = `(${rpkiNodes.length} RPKI blockchain nodes)`;
    document.getElementById('node-tbody').innerHTML = rpkiNodes.map(n => `
      <tr>
        <td><strong>AS${n.asn}</strong></td>
        <td>${fmt(n.processed)} / ${fmt(n.total_observations)}</td>
        <td>
          <div class="progress-bar"><div class="fill" style="width:${n.progress_pct}%"></div></div>
          <span style="font-size:0.75rem;color:var(--muted)">${n.progress_pct}%</span>
        </td>
        <td>${n.tps}</td>
        <td>${n.attacks_detected}</td>
        <td>${n.buffer_queued}/${n.buffer_max}</td>
        <td style="font-size:0.78rem">${fmtTsShort(n.last_bgp_timestamp)}</td>
        <td>${n.running ? '<span class="badge badge-running">Running</span>' : '<span class="badge badge-done">Done</span>'}</td>
      </tr>
    `).join('');

    // ── Node Activity Feed ──
    await pollActivity();

  } catch (err) {
    console.error('Poll error:', err);
  }
}

// Activity feed polling (separate to allow independent dropdown changes)
let _lastActivityASN = 0;
async function pollActivity() {
  const sel = document.getElementById('activity-node-select');
  const asn = parseInt(sel.value);
  if (!asn) return;

  try {
    const data = await fetchJSON('/api/node_activity/' + asn);
    if (data.error) return;

    // Stats row
    const statsEl = document.getElementById('activity-stats');
    statsEl.innerHTML = [
      ['Processed', `${data.processed}/${data.total}`],
      ['TPS', data.tps],
      ['Attacks', data.attacks_detected],
      ['Buffer', `${data.buffer_queued}/${data.buffer_max}`],
      ['TX Created', data.stats?.transactions_created || 0],
      ['Deduped', data.stats?.transactions_deduped || 0],
    ].map(([k,v]) => `<span><strong style="color:var(--accent)">${v}</strong> <span style="color:var(--muted)">${k}</span></span>`).join('');

    // Step timings
    if (data.step_timings && Object.keys(data.step_timings).length > 0) {
      const t = data.step_timings;
      statsEl.innerHTML += '<br>' + Object.entries(t).map(([k,v]) =>
        `<span style="margin-right:12px;"><span style="color:var(--muted)">${k.replace('_ms','')}</span>: <strong>${v.toFixed(2)}ms</strong></span>`
      ).join('');
    }

    // Info label
    document.getElementById('activity-node-info').textContent =
      `${data.is_rpki ? 'RPKI Validator' : 'Observer'} | ${data.running ? 'Running' : 'Done'}`;

    // Event feed
    const feedEl = document.getElementById('activity-feed');
    if (data.events.length === 0) {
      feedEl.innerHTML = '<div style="color:var(--muted);padding:12px;">No events yet for this node...</div>';
      return;
    }

    feedEl.innerHTML = data.events.map(e => {
      let iconCls = 'activity-icon-ok';
      let labelHtml = '';
      if (e.is_attack && e.detected) {
        iconCls = 'activity-icon-attack';
        labelHtml = `<span class="activity-label" style="background:rgba(239,83,80,0.2);color:var(--red)">ATTACK DETECTED</span>`;
      } else if (e.is_attack && !e.detected) {
        iconCls = 'activity-icon-detect';
        labelHtml = `<span class="activity-label" style="background:rgba(255,167,38,0.2);color:var(--orange)">MISSED</span>`;
      } else if (!e.is_attack && e.detected) {
        iconCls = 'activity-icon-detect';
        labelHtml = `<span class="activity-label" style="background:rgba(255,167,38,0.2);color:var(--orange)">FALSE POS</span>`;
      } else if (e.action === 'skipped_dedup' || e.action === 'skipped_throttle') {
        iconCls = 'activity-icon-skip';
        labelHtml = `<span class="activity-label" style="background:rgba(136,136,136,0.2);color:var(--muted)">DEDUP</span>`;
      } else if (e.action === 'transaction_broadcast') {
        iconCls = 'activity-icon-tx';
        labelHtml = `<span class="activity-label" style="background:rgba(79,195,247,0.2);color:var(--accent)">TX</span>`;
      } else {
        labelHtml = `<span class="activity-label" style="background:rgba(102,187,106,0.15);color:var(--green)">OK</span>`;
      }

      const typeStr = e.detection_type ? ` [${e.detection_type}]` : '';
      return `<div class="activity-row">
        <div class="activity-icon ${iconCls}"></div>
        <div class="activity-action">${e.action || '--'}</div>
        <div class="activity-prefix">${e.prefix} (AS${e.origin_asn})${typeStr}</div>
        ${labelHtml}
      </div>`;
    }).join('');

  } catch(e) {
    console.error('Activity poll error:', e);
  }
}

// Auto-select first RPKI node after initial load
document.getElementById('activity-node-select').addEventListener('change', pollActivity);

// Load system info once
fetchJSON('/api/system_info').then(info => {
  const parts = [];
  if (info.cpu_model) parts.push('CPU: ' + info.cpu_model);
  else if (info.processor) parts.push('CPU: ' + info.processor);
  if (info.cpu_count) parts.push('Cores: ' + info.cpu_count);
  if (info.memory_total_gb) parts.push('RAM: ' + info.memory_total_gb + ' GB');
  if (info.python_version) parts.push('Python ' + info.python_version);
  if (info.platform) parts.push(info.platform);
  document.getElementById('sysinfo-bar').textContent = parts.join('  |  ');
}).catch(() => {});

poll();
setInterval(poll, POLL_MS);
</script>

</body>
</html>
