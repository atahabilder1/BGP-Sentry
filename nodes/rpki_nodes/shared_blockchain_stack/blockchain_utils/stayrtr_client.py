#!/usr/bin/env python3
"""
StayRTR Client - RPKI Route Validation via VRP data.

Primary mode: reads the VRP JSON file directly (fast, no daemon needed).
Optional mode: queries a running StayRTR daemon via RTR protocol.
"""

import json
import logging
import ipaddress
from pathlib import Path
from typing import Optional

logger = logging.getLogger(__name__)


class StayRTRClient:
    """
    Validates BGP routes against a VRP (Validated ROA Payload) table.

    The VRP is typically generated by scripts/generate_vrp.py from the
    dataset's legitimate observations, or fetched from a real RPKI cache.
    """

    def __init__(self, vrp_path: str = "stayrtr/vrp_generated.json"):
        """
        Args:
            vrp_path: Path to StayRTR-format VRP JSON file.
        """
        self.vrp_path = Path(vrp_path)
        self._roa_table = []    # List of (network, max_length, origin_asn)
        self._loaded = False

    def load(self) -> bool:
        """Load VRP data from JSON file. Returns True on success."""
        if not self.vrp_path.exists():
            logger.warning(f"VRP file not found: {self.vrp_path}")
            return False

        try:
            with open(self.vrp_path, "r") as f:
                data = json.load(f)

            self._roa_table = []
            for roa in data.get("roas", []):
                asn_str = roa.get("asn", "")
                # Parse "AS6300" -> 6300
                if asn_str.startswith("AS"):
                    origin_asn = int(asn_str[2:])
                else:
                    origin_asn = int(asn_str)

                prefix = roa.get("prefix")
                max_length = roa.get("maxLength", 32)

                try:
                    network = ipaddress.ip_network(prefix, strict=False)
                except ValueError:
                    continue

                self._roa_table.append((network, max_length, origin_asn))

            self._loaded = True
            logger.info(f"Loaded {len(self._roa_table)} ROA entries from {self.vrp_path}")
            return True

        except Exception as e:
            logger.error(f"Failed to load VRP: {e}")
            return False

    def validate_route(self, prefix: str, origin_asn: int) -> str:
        """
        Validate a BGP route against the VRP table.

        Args:
            prefix: IP prefix (e.g. "1.2.0.0/16")
            origin_asn: Origin AS number

        Returns:
            "valid"     - ROA exists, origin and prefix match
            "invalid"   - ROA exists for prefix but origin doesn't match
            "not_found" - No ROA covers this prefix
        """
        if not self._loaded:
            self.load()

        try:
            announced = ipaddress.ip_network(prefix, strict=False)
        except ValueError:
            return "not_found"

        found_covering_roa = False

        for roa_network, roa_max_length, roa_asn in self._roa_table:
            # Check if ROA covers the announced prefix
            if announced.version != roa_network.version:
                continue

            if not _is_subprefix(announced, roa_network):
                continue

            # ROA covers this prefix range
            if announced.prefixlen > roa_max_length:
                continue  # More specific than allowed

            found_covering_roa = True

            # Check origin match
            if roa_asn == origin_asn:
                return "valid"

        if found_covering_roa:
            return "invalid"  # Covered by ROA but wrong origin
        return "not_found"

    def get_valid_origins(self, prefix: str) -> list:
        """Get list of valid origin ASNs for a given prefix."""
        if not self._loaded:
            self.load()

        try:
            announced = ipaddress.ip_network(prefix, strict=False)
        except ValueError:
            return []

        origins = []
        for roa_network, roa_max_length, roa_asn in self._roa_table:
            if announced.version != roa_network.version:
                continue
            if _is_subprefix(announced, roa_network) and announced.prefixlen <= roa_max_length:
                origins.append(roa_asn)

        return origins


def _is_subprefix(child: ipaddress._BaseNetwork, parent: ipaddress._BaseNetwork) -> bool:
    """Check if child is a subprefix of (or equal to) parent."""
    return (
        child.network_address >= parent.network_address
        and child.broadcast_address <= parent.broadcast_address
    )
